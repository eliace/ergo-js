## Область видимости и контекст

#### Область видимости (скоуп)

Область видимости (скоуп) объекта формируется из контекста. В свою очередь контекст дочерних объектов формируется из области видимости родительского. Таким образом получается каскадируемый контекст, похожий по своему поведению на прототипное наследование javascript.

```javascript
new Html({
    scope: {
        // добавляя переменную в скоуп мы делаем ее доступной всем дочерним элементам на всех уровнях
        title: 'Coffee'
    },
    $header: {
        $title: {
            $link: {
                // здесь значение переменной title можно получить через скоуп
            }
        }
    }
});
```
Каждый компонент имеет свой объект `scope`. Скоупы компонентов `$header` и `$link` не равны друг другу, но содержат те же переменные. Это означает, что доабвление новых переменных в скоупах потомков не влияет на родительский скоуп.

#### Иерархия областей видимости
```javascript
new Html({
    // вэтом скоупе только description
    scope: {
        description: 'Hello'
    },
    $image: {
        // этот скоуп содержит и image, и description
        scope: {
            image: 'mountains.jpg'
        },
        html: 'img',
        src: $value('image'),
        alt: $value('description'),
    }
});
```

#### Область видимости класса
Как только мы выносим некоторый функционал в отдельный класс, вместе с ним можно вынести и определения области видимости. Нюанс только в том, что данные на уровне класса не известны. Мы можем, к примеру, выставить значения по умолчанию.

```javascript
class Image extends Html {
    config () {
        return {
            // описываем скоуп пустыми значениями
            scope: {
                image: ''
                description: ''
            },
            html: 'img',
            src: $value('image'),
            alt: $value('description'),
        }
    }
}

new Html({
    $image: {
        as: Image,
        // перекрываем скоуп компонента image своими значениями
        scope: {
            description: 'Hello',
            image: 'mountains.jpg'
        }
    }
});
```

#### Контекст
Задавая скоуп в каждом отдельном компоненте мы быстро превратим наш код в спагетти. Гораздо удобнее управлять всем из одного корневого скоупа, которому потомки "делегируют" свои переменные (если мы смотрим на проблему со стороны компонентов-потомков). Но для этого скоуп класса должен понимать, что данные нужно откуда-то взять. Откуда? Конечно из контекста, который по сути является скоупом родителя.
```javascript
class Image extends Html {
    config () {
        return {
            scope: {
                image: (ctx) => ctx.image || '', // переменная скоупа может быть задана как функция инициализации
                description: (ctx) => ctx.image || ''
            }
        }
    }
}
new Html({
    scope: {
        image: 'sunflower.jpg'
    },
    $content: {
        $image: {
            as: Image
        }
    }
});
```

Итак, мы создали отдельный класс, в котором есть переменная скоупа `image` и через которую задается url картинки. А что, если таких картинок несколько и в корневом скоупе они, естественно, называются по-разному?
```javascript
new Html({
    scope: {
        image1: 'sunflower.jpg',
        image2: 'mountains.jpg'
    },
    $header: {
        // здесь мы можем ввести в скоуп переменную image, которая будет использована дочерним Image
        scope: {
            image: (ctx) => ctx.image1
        },
        $image: {
            as: Image
        }
    },
    $footer: {
        scope: {
            image: (ctx) => ctx.image2
        },
        $image: {
            as: Image
        }
    }
});
```
<div class="alert is-info">
Пирведенный выше пример искуственный, нужный только для демонстрации работы с областями видимости. Простые значения лучше всего связывать через опции.
</div>

## Реактивность
Для того, чтобы возникала реакция, компонент должен подписаться на изменения переменной (связывание). Это происходит в случаях, когда среди опций есть:
* реактивная функция (`changed`) с именем переменной
* реактивные значения, связанные с именем переменной
* функции согласования (`joined`) с именем переменной
* общая функция согласования `allJoined`

#### Реактивная функция
```javascript
new Html({
    scope: {
        data: 100,
        title: 'Hello'
    },
    $content: {
        dataChanged: function (v) {
            // v == 100
            // здесь мы можем изменить свойства компонента
        }
    },
    $description: {
        titleChanged: function (v) {
            // v == 'Hello'
            // изменим свойство text
            this.opt('text', v)
        }
    }
});
```

#### Реактивное значение
```javascript
new Html({
    scope: {
        pic: 'sunflower.jpg',
        title: 'Hello'
    },
    $header: {
        text: $value('title') // связываем опцию text со значением переменной скоупа title
    },
    $image: {
        src: $value('pic')
    }
});
```


## Коллекции
Коллекции в javascript представлены типами `Object` и `Array`. В первую очередь компонентам коллекции нужны для управления структурой, т.е. для свойств `components` и `items`. Рассмотрим, как они работают со связанными данными

#### Итератор
Мы можем связать структурные свойства, как и простые - через `$value`
```javascript
new Html({
    scope: {
        list: ['Coffee', 'Tea', 'Milk'],
        map: {
            header: true,
            content: true,
            footer: false
        }
    },
    $header: {
        // в контексте есть переменная map = {header: true, content: true, footer: false}
    },
    $content: {
        defaultItem: {
            // через контекст нам доступна переменная list = ['Coffee', 'Tea', 'Milk']
        },
        items: $value('list')
    },
    $footer: {},
    components: $value('map')
});
```
Структура создается, соответсвенно связанным данным, но дочерние элементы не имеют собственного контекста - их скоупы идентичны скоупу родителя.

Для создания дочернего скоупа мы можем воспользоваться итератором
```javascript
new Html({
    scope: {
        list: ['Coffee', 'Tea', 'Milk']
    },
    $content: {
        defaultItem: {
            // теперь в скоупе есть переменная item, равная для каждого из элементов 'Coffee', 'Tea' или 'Milk'
        },
        items: $iterator('list', 'item')
    }
});
```
<div class="alert is-info">
Поведение components аналогично поведению items
</div>



## Совместное использование данных
Рассмотрим пример, где в двух разных ветках дерева компонентов находятся тесктовое поле и поле ввода
```javascript
new Html({
    scope: {
        num: 0
    },
    $form: {
        $input: {
            html: 'input',
            numChanged: function (v) {
                this.opt('value', v)
            },
            onChange: function (e, $scope) {
                $scope.num.$set(e.target.value)  // в скоупе на самом деле находится реактивная обертка над num
            }
        },
        $result: {
            numChanged: function (v) {
                this.opt('text', v)
            }
        }
    }
});
```
При изменении данных в поле ввода, меняются данные и в текстовом поле. Это реализуется за счет реактивных оберток над данными, которые создаются в скоупе.
<div class="alert is-info">
Сами данные не меняются, не копируются, а остаются как есть. Это значит, что компоненты могут совместно использовать практически любые объекты, даже другие компоненты или их конфигурации.
</div>

```javascript
new Html({
    scope: {
        columns: [{
            text: 'num',
            width: '20%'            
        }, {
            text: 'title',
            width: '80%'
        }]
    },
    $table: {
        html: 'table',
        $header: {
            html: 'thead',
            $columns: {
                html: 'tr',
                columnsChanged: function (v) {
                    this.opt('items', v) // значение колонок используется как набор опций дочерних элементов
                }
            }
        }
    }
});
```

## Каналы
Можно сказать, что это сложная тема, поскольку речь не пойдет о технологии, а о несколько иной точке зрения на проблему.

Элементы структуры являются самодостаточными, они могут управлять прямыми потомками, знают родителе и имеют контекст, определяющий их текущее состояние. Все понятно с корневым элементом и элементами-листьями: корневой элемент содержит в себе общее состояние, а листья - примитивные состояния, являющиеся частью общего. Отсюда легко определить их задачи:
* root - максимально полное описание модели данных структуры
* leaf - отображение примитивных данных на свойства отрисовки

А что с элементами посередине, ветвями? Внезапно, если их не игнорировать, оказывается, что функций здесь заметно больше:

1. доставить даные от корня к листьям, причем эти данные для ветвей могут даже не нести смысла на уровне ветви
2. добнасытить контекст локальными данными
3. ветвями может потребляться часть данных, как правило тех, которые влияют на низлежащую структуру

Из сказанного выше следует, что скоуп промежуточного элемента может быть наполнен неизвестными и неконтролируемыми данными.

Есть еще одна неочевидная проблема, связанная с реактивными обертками. Скоупы являются независимыми друг от друга, а значит должны иметь свои собственные обертки, которые реагируют на изменения. Но в таком случае родительские скоупы никогда не узнают об изменениях в дочерних. Для того, чтобы данные корректно распространялись, скоупы используют одни и те же обертки, как бы пронизывая структуру сверху вниз, формируя таким образом канал передачи данных. С точки зрения скоупов переменные это именованные каналы распространения данных.
<div class="alert is-info">
Особенность реализации реактивной обертки в том, что она не содержит самих данных, а только путь к ним в структуре данных.
</div>




```javascript
new Html({
    scope: {
        // title и color выставляются один раз при создании компонента, значит их можно объединить в один канал data
        data: {
            title: 'Coffee',
            color: 'red'
        }
    },
    $header: {
        $title: {
            dataChanged: function (v) {
                this.opt('text', v.text)
                this.opt('styles', {color: v.color})
            }
        }
    }
});
```


#### Разделение каналов

#### Согласование каналов
join all

#### Настройка канала
в том числе адаптация канала